#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline author:t c:nil
#+OPTIONS: creator:nil d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t
#+OPTIONS: num:t p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t timestamp:t
#+OPTIONS: title:t toc:nil todo:t |:t
#+TITLE: The History and Future of Core Dumps in FreeBSD
#+DATE: \today
#+AUTHOR: Sam Gwydir, Texas A&M University
#+EMAIL: sam@samgwydir.com
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 25.1.1 (Org mode 8.3.5)
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper,article,twocolumn]
#+LATEX_HEADER: \usepackage[top=1.5in, bottom=1.50in, left=1.00in, right=1.00in]{geometry}
#+LATEX_HEADER: \setlength{\parindent}{4em}
#+LATEX_HEADER: \setlength{\parskip}{1em}
#+LATEX_HEADER_EXTRA:
#+DESCRIPTION:
#+KEYWORDS:
#+SUBTITLE:

#+BEGIN_COMMENT

- SUBMIT TO: secretary@asiabsdcon.org
- EMAIL:
  - Paper title
  - Abstract
  - Names and affiliations of the authors
  - Name of the speaker and whether a visa application is required or not to visit Japan
  - Estimation of your travel expense
  - Contact email address


- There is a significant problem being solved or a real world experience being demonstrated.
- There is active work being done.
- There is enough progress to make a complete written submission.
- There is data proving either the success or failure of any claims.

-Questions

Q: Are we going to focus on amd64 and x86?

Outline
- What is a core dump?
- System 6
- Crash(8)
If the reason for the crash is not evident
(see below for guidance on `evident')
you may want to try to dump the system if you feel up to
debugging.
At the moment a dump can be taken only on magtape.
With a tape mounted and ready,
stop the machine, load address 44, and start.
This should write a copy of all of core
on the tape with an EOF mark.

- 3BSD
added to crash(8) in 3BSD: (Someday the LSI-11 will do this automatically.)

root@freebsd-current:~/src/unix-history-repo # git branch
  BSD-3-Snapshot-Development
root@freebsd-current:~/src/unix-history-repo # git log usr/src/sys/sys/locore.s
commit 78bb3f5f916ebc2ee66d7dbfbe93db9a97e6d3ca
Author: Ozalp Babaoglu <ozalp@ucbvax.Berkeley.EDU>
Date:   Wed Jan 16 00:08:32 1980 -0800

    BSD 3 development
    Work on file usr/src/sys/sys/locore.s

    Co-Authored-By: Bill Joy <wnj@ucbvax.Berkeley.EDU>
    Co-Authored-By: Juan Porcar <x-jp@ucbvax.Berkeley.EDU>
    Synthesized-from: 3bsd
root@freebsd-current:~/src/unix-history-repo # grep -A20 doadump usr/src/sys/sys/locore.s
	.globl	doadump
doadump:
	movl	sp,dumpstack		# save stack pointer
	movab	dumpstack,sp		# reinit stack
	mfpr	$PCBB,-(sp)		# save u-area pointer
	mfpr	$MAPEN,-(sp)		# save value
	mfpr	$IPL,-(sp)		# ...
	mtpr	$0,$MAPEN		# turn off memory mapping
	mtpr	$HIGH,$IPL		# disable interrupts
	pushr	$0x3fff			# save regs 0 - 13
	calls	$0,_dump		# produce dump
	halt

	.data
	.align	2
	.globl	dumpstack
	.space	58*4			# separate stack for tape dumps
- 4.2BSD
  - /usr/src/sys/vax/vax/machdep.c
  - doadump and dumpsys
  - 'doadump() { dumpsys(); }'
- FreeBSD Dumping History
  - The Design and Implementation of FreeBSD
  - Canonical BSD Unix core memory dumping: All memory to a
       pre-designated device
    - 64kb indent, starts dumping at END of dump dev in case you
         start swapping early in boot before you retrieve the dump.
         4.2BSD?
    - kern/kern\_shutdown.c (Traditional)
- FreeBSD Dumping Present
  - Dumps on machines with 300 GB of RAM+ can be huge
    - Swap partitions need not be so large for any other reason
  - Updated FreeBSD dumping
    - 64kb indent, dump from end preserved (verify)
      - sys/kern/kern\_dump.c
      - sys/kern/kern\_shutdown.c
      - sys/amd64/amd64/machdep\_minidump.c
      - and rarely bits might be in sys/amd64/amd64/pmap.c
    - “Minidumps” of only active kernel pages
    - Dump time DDB scripting
      - Useful if you don't have a dump device
      - DDB must be built into the kernel
      - No performance penalty but...
      - Security risk with the CTRL-ALT-ESC shortcut
        - Can be disabled at compile time, FreeNAS does this
- "No, as I recall on an IBM 360 you could pick line printer or punched cards... lol"
- It may be worth looking at the games Linux plays. Reserve space for a kernel, load that kernel...
- Perhaps: Paper -> Tape -> Swap -> New fancy stuff.
- "https://en.wikipedia.org/wiki/Core_dump    The background starts off with core dumps were paper printouts[6]... "
- So here’s Bell 32/V doadump: https://github.com/dspinellis/unix-history-repo/blob/Bell-32V-Snapshot-Development/usr/src/sys/sys/locore.s
- "IIRC many systems from the early 70's and before did crash dumps to printer.  I am not sure when the idea of saving the bits in a machine readable form for analisys after coming back up  started."
- [12/23/16, 16:02:56] Michael Dexter: "Well in 1979 I can remeber doing a crash dump on a Harris S/210 24 bit machine to the line printer in octal, it only took 2 hours to print...."
[12/23/16, 16:03:35] gwydirsam: -rgrimes?
- From Rod: "[12/23/16 1:51:05 PM] Rodney Grimes: I would say dumps to swap/page area was soon to come:   7. Reboot fixups
 Support automatic dumps to paging area
[12/23/16 1:51:24 PM] Rodney Grimes: That is on a list of TODO's in https://github.com/dspinellis/unix-history-repo/blob/BSD-4-Snapshot-Development/usr/src/sys/sys/TODO "
- multics
  - http://multicians.org/mgf.html#fdump
- OS X dump server
- https://developer.apple.com/library/content/technotes/tn2004/tn2118.html
- 
- FreeBSD Dumping Future
  - Netdumps
  - Compressed Dumps
  - Encrypted Dumps
  - New features at various stages of integration
    - Netdumps
      - Duke University code from long ago
      - Picked up by Ed Maste at Sandvine, dropped
      - Picked up by Isilon
        - Added compression code? Picked it up
      - Modular...
    - Encryption - landed in head 12/10/2016 (Verify)

#+END_COMMENT



# * Introduction

# Crash dumps, also known as core dumps, have been a part of BSD since it's
# beginning. A core dump is ``a copy of memory that is saved on secondary storage
# by the kernel''^[1] for debugging a system failure. Though 36 years have passed
# since =doadump= came about in 3BSD, core dumps are still created and utilized in
# much the same way they were then. In addition a call to action will be made for
# modularizing the core dump code.

* Introduction

The BSD core dump facility performs a simple yet vital service to the operator:
preserving a copy of the contents of system memory at the time of a fatal error,
or =panic(9)=. This copy can represent a machine readable dump of the contents of system
memory, a subset of those kernel pages that are active at the time of the crash, or a
less complete but human readable form using debugger scripting.

The FreeBSD variant of the BSD operating system has introduced gradual
extensions to the core dumping facility in the form of, ``minidumps'' that only
represent active kernel memory, ``textdumps(4)'' consisting of the result of debugger
scripting at the time of panic, encrypted dumps, compressed dumps and the
ability to dump to a remote network device. While promising, these extensions
have been inconsistent in their integration and interoperability.

# (And if we're
# lucky, some news about dump procedures relating to hibernation and virtual
# machine migration!)

This paper will provide a historical survey of the dump facility itself, these
dump extensions, and describe an active effort to fully modularize them, allowing
the operator to enable one or more of them simultaneously. It will also address
related utilities to determine the size of a dump in advance and kernel debugger
(DDB) scripting options.


* Motivation

Though core dumps were originally made to magnetic tape, dumps
have been made to a swap partition on a hard disk since at least 3BSD.
For decades since, increases in physical system memory and swap partition size have
loosely tracked increases in available persistent memory, allowing for the
continued use of this paradigm. 

# Since 4.1BSD, an
# operator would allocate a region on disk to a ``dumpdev'' that is equal to
# physical system memory plus a small buffer. 

However, recent advances in commodity system hardware have upended the
traditional memory to disk space ratio with systems now routinely utilizing 1TB
or more physical memory whilst running on relatively small solid state disks.
Given that the kernel memory footprint has grown in size, the assumption that
disk space would always allow for a swap partition large enough for a core dump
has proved to be inaccurate. This change has spurred development of
several extensions to the core dumping facility, including compressed dumping
and dumping over the network to a server with disk space for modern core dumps.
Network Dumping, or =netdump= does have some security implications which recent
work on encrypted dumping may resolve.

* Background
  # - Canonical BSD Unix core memory dumping: All memory to a
  #      pre-designated device
  #   - 64kb indent, starts dumping at END of dump dev in case you
  #        start swapping early in boot before you retrieve the dump.
  #        4.2BSD?
  #   - kern/kern\_shutdown.c (Traditional)

  #   - Backtrace.io paper here
  # https://backtrace.io/blog/improving-freebsd-kernel-debugging/

When a UNIX-like system such as FreeBSD encounters an unrecoverable and
unexpected error the kernel will "panic". Though the word panic has connotations
of irrationality, the function =panic(9)= maintains composure while it
"[terminates] the running system" and "[attempts] to save a core dump" to a
configured dump device. [2] Core dumps, sometimes known as crash dumps are
used to debug system failures. Crash dumps are "a copy of memory that is saved
on secondary storage by the kernel when a catastrophic failure occurs." [1]
What follows is a thorough description of the FreeBSD core dump routine starting
with =doadump()= in =sys/kern/kern_shutdown.c=. The FreeBSD operating system
source code can be checked out using subversion by following the FreeBSD
handbook instructions [3].


=doadump()= is called by =kern_reboot()=, which shutsdown "the system cleanly to
prepare for reboot, halt, or power off." [4] =kern_reboot()= calls
=doadump()= if the =RB_DUMP= flag is set and the system is not "cold" or already
creating a core dump. =doadump()= takes a boolean informing it to whether or not
to take a "text dump", a form of dump carried out if the online kernel debugger,
=DDB=, is built into the running kernel. =doaddump()= returns an error code if
the system is currently creating a dump, the dumper is NULL and returns error
codes on behalf of =dumpsys()=.

=doadump(boolean_t textdump)= starts the core dump procedure by saving the
current context with a call to =savectx()= and then invokes a core dump using
=dumpsys()=, passing it a =struct dumper= and optionally a "text dump" which is
carried out if the online kernel debugger, =DDB=, is built into the running
kernel.

=dumpsys()= is defined on a per-architecture basis. This allows different
architectures to setup their dump structure differently. =dumpsys()= calls
=dumpsys_generic()= passing along the =struct dumperinfo= it was called with.
=dumpsys_generic()= is defined in =sys/kern/kern_dump.c= and is the meat of the
core dump procedure.

There are several main steps to the dumping procedure. The main steps are as
follows. At any point if there is an error condition, goto failure cleanup at
the end of the procedure.

1. Fill in the ELF header.
2. Calculate the dump size.
3. Determine if the dump device is large enough.
4. Begin Dump
   1. Leader (Padding)
   2. ELF Header
   3. Program Headers
   4. Memory Chunks
   5. Trailer
5. End Dump

* History

** Core Dumps in UNIX
*** Research UNIX Version 5
    =usr/sys/conf/mch.s=

# https://github.com/dspinellis/unix-history-repo/blob/Research-V5-Snapshot-Development/usr/sys/conf/mch.s#L826

    #+BEGIN_SRC asm
.globl	dump
dump:
	mov	$4,r0	/ overwrites trap vectors
	mov	r1,(r0)+
	mov	r2,(r0)+
	mov	r3,(r0)+
	mov	r4,(r0)+
	mov	r5,(r0)+
	mov	sp,(r0)+
	mov	$KISA0,r1
	mov	$8.,r2
1:
	mov	(r1)+,(r0)+
	sob	r2,1b
	mov	$MTC,r0
	mov	$60004,(r0)+
	clr	2(r0)
1:
	mov	$-512.,(r0)
	inc	-(r0)
2:
	tstb	(r0)
	bge	2b
	tst	(r0)+
	bge	1b
	5
	mov	$60007,-(r0)
	br	.
    #+END_SRC
*** Research UNIX Version 6
=/usr/sys/conf/m40.s=
# https://github.com/dspinellis/unix-history-repo/blob/Research-V6-Snapshot-Development/usr/sys/conf/m40.s
    #+BEGIN_SRC asm
.globl	dump
dump:
	bit	$1,SSR0
	bne	dump

/ save regs r0,r1,r2,r3,r4,r5,r6,KIA6
/ starting at abs location 4

	mov	r0,4
	mov	$6,r0
	mov	r1,(r0)+
	mov	r2,(r0)+
	mov	r3,(r0)+
	mov	r4,(r0)+
	mov	r5,(r0)+
	mov	sp,(r0)+
	mov	KISA6,(r0)+

/ dump all of core (ie to first mt error)
/ onto mag tape. (9 track or 7 track 'binary')

	mov	$MTC,r0
	mov	$60004,(r0)+
	clr	2(r0)
1:
	mov	$-512.,(r0)
	inc	-(r0)
2:
	tstb	(r0)
	bge	2b
	tst	(r0)+
	bge	1b
	reset

/ end of file and loop

	mov	$60007,-(r0)
	br	.
    #+END_SRC

=/usr/sys/conf/m45.s=
# https://github.com/dspinellis/unix-history-repo/blob/Research-V6-Snapshot-Development/usr/sys/conf/m45.s#L21
#+BEGIN_SRC asm
/ Mag tape dump
/ save registers in low core and
/ write all core onto mag tape.
/ entry is thru 44 abs

.data
.globl	dump
dump:
	bit	$1,SSR0
	bne	dump

/ save regs r0,r1,r2,r3,r4,r5,r6,KIA6
/ starting at abs location 4

	mov	r0,4
	mov	$6,r0
	mov	r1,(r0)+
	mov	r2,(r0)+
	mov	r3,(r0)+
	mov	r4,(r0)+
	mov	r5,(r0)+
	mov	sp,(r0)+
	mov	KDSA6,(r0)+

/ dump all of core (ie to first mt error)
/ onto mag tape. (9 track or 7 track 'binary')

	mov	$MTC,r0
	mov	$60004,(r0)+
	clr	2(r0)
1:
	mov	$-512.,(r0)
	inc	-(r0)
2:
	tstb	(r0)
	bge	2b
	tst	(r0)+
	bge	1b
	reset

/ end of file and loop

	mov	$60007,-(r0)
	br	.
#+END_SRC
*** Research UNIX v7
# https://github.com/dspinellis/unix-history-repo/blob/Research-V7-Snapshot-Development/usr/sys/conf/mch.s#L26
=/usr/sys/conf/mch.s=
#+BEGIN_SRC asm
/ Mag tape dump
/ save registers in low core and
/ write all core onto mag tape.
/ entry is thru 44 abs

.data
.globl	dump
dump:

/ save regs r0,r1,r2,r3,r4,r5,r6,KIA6
/ starting at abs location 4

	mov	r0,4
	mov	$6,r0
	mov	r1,(r0)+
	mov	r2,(r0)+
	mov	r3,(r0)+
	mov	r4,(r0)+
	mov	r5,(r0)+
	mov	sp,(r0)+
	mov	KDSA6,(r0)+

/ dump all of core (ie to first mt error)
/ onto mag tape. (9 track or 7 track 'binary')

.if HTDUMP
	mov	$HTCS1,r0
	mov	$40,*$HTCS2
	mov	$2300,*$HTTC
	clr	*$HTBA
	mov	$1,(r0)
1:
	mov	$-512.,*$HTFC
	mov	$-256.,*$HTWC
	movb	$61,(r0)
2:
	tstb	(r0)
	bge	2b
	bit	$1,(r0)
	bne	2b
	bit	$40000,(r0)
	beq	1b
	mov	$27,(r0)
.endif
HT	= 0172440
HTCS1	= HT+0
HTWC	= HT+2
HTBA	= HT+4
HTFC	= HT+6
HTCS2	= HT+10
HTTC	= HT+32

MTC = 172522
.if TUDUMP
	mov	$MTC,r0
	mov	$60004,(r0)+
	clr	2(r0)
1:
	mov	$-512.,(r0)
	inc	-(r0)
2:
	tstb	(r0)
	bge	2b
	tst	(r0)+
	bge	1b
	reset

/ end of file and loop

	mov	$60007,-(r0)
.endif
	br	.
#+END_SRC

*** Bell 32/V
# https://github.com/dspinellis/unix-history-repo/blob/Bell-32V-Snapshot-Development/usr/src/sys/sys/locore.s#L158
=/usr/src/sys/sys/locore.s=
#+BEGIN_SRC asm
#  0x200
# Produce a core image dump on mag tape
	.globl	doadump
doadump:
	movl	sp,dumpstack	# save stack pointer
	movab	dumpstack,sp	# reinit stack
	mfpr	$PCBB,-(sp)	# save u-area pointer
	mfpr	$MAPEN,-(sp)	# save value
	mfpr	$IPL,-(sp)	# ...
	mtpr	$0,$MAPEN		# turn off memory mapping
	mtpr	$HIGH,$IPL		# disable interrupts
	pushr	$0x3fff			# save regs 0 - 13
	calls	$0,_dump	# produce dump
	halt

	.data
	.align	2
	.globl	dumpstack
	.space	58*4		# seperate stack for tape dumps
dumpstack: 
	.space	4
	.text
#+END_SRC

** Core Dumps in BSD
*** 1BSD & 2BSD
    - Uses v6 dump code
*** 3BSD
    # https://github.com/dspinellis/unix-history-repo/blob/BSD-3-Snapshot-Development/usr/src/sys/sys/locore.s#L174
    =/usr/src/sys/sys/locore.s=
    =doadump=
    #+BEGIN_SRC asm
# =====================================
# Produce a core image dump on mag tape
# =====================================
	.globl	doadump
doadump:
	movl	sp,dumpstack		# save stack pointer
	movab	dumpstack,sp		# reinit stack
	mfpr	$PCBB,-(sp)		# save u-area pointer
	mfpr	$MAPEN,-(sp)		# save value
	mfpr	$IPL,-(sp)		# ...
	mtpr	$0,$MAPEN		# turn off memory mapping
	mtpr	$HIGH,$IPL		# disable interrupts
	pushr	$0x3fff			# save regs 0 - 13
	calls	$0,_dump		# produce dump
	halt

	.data
	.align	2
	.globl	dumpstack
	.space	58*4			# separate stack for tape dumps
dumpstack: 
	.space	4
	.text
    #+END_SRC
*** 4BSD
    # https://github.com/dspinellis/unix-history-repo/blob/BSD-4-Snapshot-Development/usr/src/sys/sys/locore.s#L174
    - add trace information with _dumptrc
    # https://github.com/dspinellis/unix-history-repo/blob/BSD-4-Snapshot-Development/usr/src/sys/sys/TODO#L28
    - First talk of dump to swap in =/usr/src/sys/sys/TODO=
*** 4.1c2BSD
    # https://github.com/dspinellis/unix-history-repo/blob/BSD-4_1c_2-Snapshot-Development/a/sys/vax/Locore.c#L36
    - doadump calls dumpsys and is all in C now
*** 4.1BSD
    # https://github.com/dspinellis/unix-history-repo/blob/BSD-4_1_snap-Snapshot-Development/sys/sys/Locore.c#L32
    - Back to asm? Actually I might be wrong, it might be a C/asm hybrid right now
    # https://github.com/dspinellis/unix-history-repo/blob/BSD-4_1_snap-Snapshot-Development/sys/GENERIC/locore.c#L112
*** 4.2BSD
    # https://github.com/dspinellis/unix-history-repo/blob/BSD-4_1_snap-Snapshot-Development/sys/sys/Locore.c#L32


The following is a quick history of core dumps in the BSD operating systems
tracing from before the advent of =doadump= in 3BSD through to the present and a
discussion of current work on compressed dumps, dumping over the network and
encrypted dumps.

Core dumping was initially a manual process as documented in Version 6 AT&T
UNIX's =crash(8)=, an operator, ``if [they felt] up to debugging'' would:

#+BEGIN_QUOTE
With a tape mounted and ready,
stop the machine, load address 44, and start.
#+END_QUOTE

Providing the operator with a core dump on tape to debug a crashed system.

As of 3BSD and with the advent of the LSI-11 core dumping has been automated via
=doadump= ^[2], the same function name used today. =doadump= was added to 3BSD
in 1980 by Ozalp Babaoglu and was written in 33 lines of PDP-11 assembly.

# TODO check this PDP-11 assembly assertion

Beginning in 4.1BSD =doadump= was re-written in C for the VAX and placed in
=sys/vax/vax/machdep.c=.

# TODO Talk here about added architectures? Pretty much everything is the same
# from here on out just added architectures

** =netdump=

# add netdump history?
    # - Netdumps
    #   - Duke University code from long ago
    #   - Picked up by Ed Maste at Sandvine, dropped
    #   - Picked up by Isilon
    #     - Added compression code? Picked it up
    #   - Modular...
*** OS X Kernel Dump
    # https://github.com/opensource-apple/xnu/blob/27ffc00f33925b582391b1ef318b78b8bd3939d1/osfmk/kdp/kdp_core.c#L491
    =osfmk/kdp/kdp_core.c=
    - gzipped
    - net dump using kdumpd
      # https://opensource.apple.com/source/network_cmds/network_cmds-396.6/kdumpd.tproj/

** Compresssed Dump
** Encrypted Dump
    # - Encryption - landed in head 12/10/2016 (Verify)


* References

- [1] The Design and Implementation of the FreeBSD operating system by McKusick, Neville-Neil, and Watson
- [2] crash(8) - 3BSD
- [3] man 9 panic - https://www.freebsd.org/cgi/man.cgi?query=panic&apropos=0&sektion=0&manpath=FreeBSD+10.3-RELEASE+and+Ports&arch=default&format=html
- [4] =kern_shutdown.c= - =sys/kern/kern_shutdown.c=
- [5] Unix History Repository - https://github.com/dspinellis/unix-history-repo
